<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rider-Pi — Sterowanie ruchem (REST /api)</title>
  <style>
    :root { --pad: 16px; --gap: 12px; }
    body{ font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; margin:0; padding:var(--pad); background:#0e1823; color:#e6eef7; }
    .wrap{max-width:1100px;margin:0 auto}
    h1{font-size:20px;margin:0 0 var(--pad)}
    .row{display:flex;flex-wrap:wrap;gap:var(--gap);align-items:center;margin:8px 0}
    .grid{display:grid;grid-template-columns:repeat(3,160px);gap:var(--gap);justify-content:center;margin:16px 0}
    .card{ background:#0f2030; border:1px solid #1e3a56; border-radius:16px; box-shadow:0 1px 8px rgba(0,0,0,.25); padding:var(--pad); margin:0 0 var(--pad); }
    button{ padding:12px 16px; border:1px solid #24425e; border-radius:12px; background:#122435; color:#e6eef7; font-size:16px; cursor:pointer; transition:transform .03s ease, background .12s ease, border-color .12s ease; }
    button:hover{ background:#16304a; border-color:#2b5577 } button:active{ transform:scale(0.98) }
    .btn-sm{ padding:6px 10px; font-size:13px; border-radius:10px }
    label{font-size:14px;color:#b7cee3;display:flex;align-items:center;gap:8px}
    input[type="range"]{width:160px; accent-color:#6de28a}
    input[type="number"]{ width:100px;background:#0b1a27;color:#e6eef7; border:1px solid #24425e;border-radius:10px;padding:6px 8px }
    #log{ height:220px; overflow:auto; background:#0b1a27; border:1px solid #1c3349; border-radius:10px; padding:8px; font-family:ui-monospace,Consolas,monospace; font-size:13px; white-space:pre-wrap; }
    .muted{opacity:.85} .ok{color:#6de28a} .warn{color:#f0c36d} .err{color:#ff8080}
    .kbd{ font-family:ui-monospace,Consolas,monospace; background:#102233; border:1px solid #203a57; border-radius:6px; padding:2px 6px; margin:0 2px; color:#b7cee3 }
    .spacer{flex:1} a{color:#98c7ff; text-decoration:none} a:hover{text-decoration:underline}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;border-radius:999px;font-size:12px;border:1px solid #24425e;background:#0b1a27}
    .pill.ok{color:#6de28a;border-color:#2c6b48} .pill.err{color:#ff8080;border-color:#8a3a3a} .pill.warn{color:#f0c36d;border-color:#8a6a2c}
    .svc-table{width:100%;border-collapse:collapse;margin-top:8px}
    .svc-table th,.svc-table td{border-top:1px solid #1c3349;padding:8px 6px;text-align:left;font-size:14px}
    .svc-table td:nth-child(3), .svc-table td:nth-child(4){ white-space:nowrap; }
    .svc-actions{ white-space:nowrap; }
    .svc-actions button{ display:inline-block; padding:6px 10px; font-size:14px; margin:2px 3px; border-radius:10px }
    .cam{width:100%;max-width:480px;border-radius:12px;border:1px solid #1c3349;background:#0b1a27; display:block; margin:0 auto;}
    .note{font-size:13px;color:#b7cee3}
  </style>
</head>
<body>
<div class="wrap">

  <h1>Rider-Pi — Sterowanie ruchem
    <span id="apiStatus" class="muted" style="margin-left:8px">(checking…)</span>
    <span id="obstBadge" class="pill warn" style="margin-left:10px;display:none">Obstacle</span>
  </h1>

  <!-- 1) KAMERA (na górze) -->
  <div class="card" style="position:relative">
    <h2 style="font-size:16px;margin:0 0 8px">Podgląd kamery</h2>

    <!-- przyciski przypięte do prawej krawędzi karty -->
    <div style="position:absolute; right:16px; top:16px; display:flex; gap:8px; align-items:flex-end;">
      <button id="camToggle" class="btn-sm">⟳ Auto-refresh</button>
      <button id="btnUseEdge" class="btn-sm">Use EDGE</button>
      <button id="btnUseCam"  class="btn-sm">Use CAM</button>
    </div>

    <!-- obrazek wycentrowany -->
    <div class="row" style="align-items:flex-start; justify-content:center">
      <div>
        <img id="camPrev" class="cam" alt="camera preview" src="/camera/last?ts=0" />
        <div class="note" id="camInfo" style="margin-top:6px">last frame: n/a · source: n/a</div>
      </div>
    </div>
  </div>

  <!-- 2) STEROWANIE -->
  <div class="card">
    <h2 style="font-size:16px;margin:0 0 8px">Sterowanie ruchem</h2>

    <div class="row" style="margin:6px 0 10px">
      <label>Prędkość skrętu <span class="muted">(0..1)</span>:
        <input id="speedSpin" type="range" min="0" max="1" step="0.02" value="0.18" />
        <span id="speedSpinVal">0.18</span>
      </label>
      <label>Czas impulsu [s]:
        <input id="durationSpin" type="number" min="0.05" step="0.05" value="0.10" />
      </label>
      <div class="spacer"></div>
      <button id="btnStop">■ STOP</button>
    </div>

    <div class="grid">
      <div></div>
      <button id="btnFwd">↑ Forward</button>
      <div></div>
      <button id="btnLeft">← Left</button>
      <button id="btnStop2">■ Stop</button>
      <button id="btnRight">Right →</button>
      <div></div>
      <button id="btnBack">↓ Backward</button>
      <div></div>
    </div>

    <div class="row">
      <span class="muted">Skróty: <span class="kbd">W</span>/<span class="kbd">S</span>/<span class="kbd">A</span>/<span class="kbd">D</span> lub strzałki; <span class="kbd">Spacja</span> = stop.</span>
      <div class="spacer"></div>
      <a href="/" class="muted">↩ dashboard</a>
    </div>
  </div>

  <!-- 3) USŁUGI -->
  <div class="card">
    <h2 style="font-size:16px;margin:0 0 8px">Usługi (systemd)
      <button id="svcRefresh" class="btn-sm" style="margin-left:8px">⟳ odśwież</button>
    </h2>
    <div id="svcInfo" class="muted">Ładowanie… <span id="svcTs"></span></div>
    <table class="svc-table" id="svcTable" style="display:none">
      <thead>
        <tr>
          <th>Unit</th><th>Opis</th><th>Status</th><th>Autostart</th><th>Akcje</th>
        </tr>
      </thead>
      <tbody id="svcBody"></tbody>
    </table>
  </div>

  <!-- 4) LOG -->
  <div class="card">
    <h2 style="font-size:16px;margin:0 0 8px">Zdarzenia (SSE /events)</h2>
    <div id="log"></div>
  </div>
</div>

<script>
  // helpers
  const qs = (s)=>document.querySelector(s);
  const logEl = qs('#log');
  function appendLog(msg, cls=""){ const line=document.createElement('div'); if(cls) line.className=cls; line.textContent=`[${new Date().toLocaleTimeString()}] ${msg}`; logEl.appendChild(line); logEl.scrollTop=logEl.scrollHeight; }
  window.addEventListener('error', e=> appendLog(`JS error: ${e.message}`, 'err'));
  window.addEventListener('unhandledrejection', e=> appendLog(`Promise error: ${e.reason}`, 'err'));

  // === Sterowanie ruchem (jak było) ===
  const LIN_V = 0.10, LIN_T = 0.10;
  const spinEl = qs('#speedSpin'), spinVal = qs('#speedSpinVal'), durSpinEl = qs('#durationSpin');
  spinEl.addEventListener('input', ()=> spinVal.textContent = Number(spinEl.value).toFixed(2));
  function clamp(n, lo, hi){ n=Number(n)||0; return Math.max(lo, Math.min(hi, n)); }

  async function pingHealth(){
    try{
      const r=await fetch('/healthz',{cache:'no-store'}); const j=await r.json().catch(()=>({}));
      const apiStatus = qs('#apiStatus'); const ok=!!j.ok; apiStatus.textContent= ok?'ok':'degraded'; apiStatus.className = ok?'ok':'warn';
    }catch(e){ const apiStatus = qs('#apiStatus'); apiStatus.textContent='down'; apiStatus.className='err'; }
  }
  setInterval(()=>{ try{ pingHealth(); }catch(_){/*noop*/} }, 1000); pingHealth();

  async function httpPost(url, body){
    const r=await fetch(url,{ method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(body)});
    const t=await r.text(); let j=null; try{ j=JSON.parse(t);}catch{}
    if(!r.ok){ throw new Error((j && (j.error||j.stderr||j.stdout)) || `HTTP ${r.status}`); }
    return j||{};
  }
  async function apiControl(obj){ try{ const j= await httpPost('/api/control', obj); appendLog(`api/control → ${JSON.stringify(obj)} :: ${JSON.stringify(j)}`, 'ok'); return j; }catch(e){ appendLog(`api/control ${JSON.stringify(obj)} :: ${e.message}`,'err'); } }
  async function doStop(){ try{ await apiControl({cmd:'stop'}); }catch(_){} }
  async function goF(){ const t=Math.max(0.05, LIN_T); await apiControl({cmd:'move', dir:'forward', v: LIN_V, t}); setTimeout(()=>{try{doStop();}catch(_){}} , Math.max(100, t*1000)); }
  async function goB(){ const t=Math.max(0.05, LIN_T); await apiControl({cmd:'move', dir:'backward', v: LIN_V, t}); setTimeout(()=>{try{doStop();}catch(_){}} , Math.max(100, t*1000)); }
  async function spin(dir){ const w=clamp(spinEl.value,0,1); const t=clamp(durSpinEl.value,0.05,5); await apiControl({cmd:'move', dir:(dir==='left'?'left':'right'), w, t}); setTimeout(()=>{try{doStop();}catch(_){}} , Math.max(100, t*1000)); }
  qs('#btnFwd').addEventListener('click', ()=>{try{goF();}catch(_){}}); qs('#btnBack').addEventListener('click', ()=>{try{goB();}catch(_){}} );
  qs('#btnLeft').addEventListener('click', ()=>{try{spin('left');}catch(_){}}); qs('#btnRight').addEventListener('click', ()=>{try{spin('right');}catch(_){}} );
  qs('#btnStop').addEventListener('click', ()=>{try{doStop();}catch(_){}}); qs('#btnStop2').addEventListener('click', ()=>{try{doStop();}catch(_){}});

  // klawiatura
  const pressed = new Set(); const isArrow = k => ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(k);
  window.addEventListener('keydown', ev=>{ try{
    if(ev.repeat) return; const k=ev.key; if(isArrow(k)) ev.preventDefault(); pressed.add(k);
    if(k===' ') {ev.preventDefault(); doStop(); return;}
    if(k==='w'||k==='W'||k==='ArrowUp') goF();
    if(k==='s'||k==='S'||k==='ArrowDown') goB();
    if(k==='a'||k==='A'||k==='ArrowLeft') spin('left');
    if(k==='d'||k==='D'||k==='ArrowRight') spin('right');
  }catch(_){}} );
  window.addEventListener('keyup', ev=>{ try{
    if(!pressed.has(ev.key)) return; pressed.delete(ev.key);
    if(['w','W','ArrowUp','s','S','ArrowDown','a','A','ArrowLeft','d','D','ArrowRight'].includes(ev.key)) doStop();
  }catch(_){}} );
  document.addEventListener('visibilitychange', ()=> { if (document.hidden) { try{doStop();}catch(_){ } } });
  window.addEventListener('beforeunload', ()=> { try { navigator.sendBeacon('/api/control', new Blob(['{"cmd":"stop"}'], {type:'application/json'})); } catch(_){} });

  // obstacle badge
  async function pollObstacle(){
    try{
      const r = await fetch('/vision/obstacle', {cache:'no-store'});
      if(!r.ok) throw 0;
      const j = await r.json().catch(()=>({}));
      const present = !!(j && (j.present || j.obstacle || (j.data && j.data.present)));
      const obstBadge = qs('#obstBadge');
      obstBadge.style.display = 'inline-flex';
      obstBadge.textContent = present ? 'Obstacle: present' : 'Obstacle: none';
      obstBadge.className = 'pill ' + (present ? 'err' : 'ok');
    }catch(_){
      const obstBadge = qs('#obstBadge');
      obstBadge.style.display = 'inline-flex';
      obstBadge.textContent = 'Obstacle: n/a';
      obstBadge.className = 'pill warn';
    }
  }
  setInterval(()=>{ try{pollObstacle();}catch(_){ } }, 1500); pollObstacle();

  // kamera
  const camImg = qs('#camPrev'); const camToggle = qs('#camToggle'); const camInfo = qs('#camInfo');
  let camAuto = true; let camTimer = null;
  function refreshCam(){ try{ camImg.src = '/camera/last?ts=' + Date.now(); }catch(_){ } }
  function setCamAuto(on){
    camAuto = on; camToggle.textContent = on ? '⟳ Auto-refresh (on)' : '⟳ Auto-refresh (off)';
    if(camTimer){ clearInterval(camTimer); camTimer=null; }
    if(on){ refreshCam(); camTimer = setInterval(()=>{try{refreshCam();}catch(_){ }}, 1500); }
  }
  camToggle.addEventListener('click', ()=> setCamAuto(!camAuto));
  setCamAuto(true);

  async function probeLastFrameAge(){
    try{
      const r = await fetch('/camera/last', { method:'HEAD', cache:'no-store' });
      const lm = r.headers.get('Last-Modified');
      let ageTxt = 'n/a';
      if(lm){
        const ts = new Date(lm).getTime();
        const age = Math.max(0, (Date.now()-ts)/1000);
        ageTxt = age.toFixed(1) + ' s';
      }
      const src = await guessFrameSource();
      camInfo.textContent = `last frame: ${ageTxt} · source: ${src}`;
      camInfo.className = 'note ' + ((lm)? (parseFloat(ageTxt) < 3 ? 'ok':'warn') : 'err');
    }catch{
      camInfo.textContent = 'last frame: n/a · source: n/a';
      camInfo.className = 'note err';
    }
  }
  setInterval(()=>{ try{probeLastFrameAge();}catch(_){ } }, 1500); probeLastFrameAge();

  // /svc
  const svcInfo = qs('#svcInfo'); const svcTable = qs('#svcTable'); const svcBody = qs('#svcBody'); const svcTs = qs('#svcTs');
  qs('#svcRefresh').addEventListener('click', ()=>{ try{fetchServices();}catch(_){ } });

  function badge(active, sub){
    let cls='warn', txt=String(active||'unknown'); if(active==='active') cls='ok';
    if(active==='failed' || active==='inactive') cls=(active==='failed'?'err':'warn');
    return `<span class="pill ${cls}">${txt}${sub?` / ${sub}`:''}</span>`;
  }
  function badgeEnabled(state){
    let cls='warn'; if(state==='enabled') cls='ok'; if(state==='disabled') cls='warn';
    return `<span class="pill ${cls}">${state||'unknown'}</span>`;
  }

  async function fetchServices(){
    try{
      const r = await fetch('/svc', {cache:'no-store'});
      const j = await r.json().catch(()=>null);
      const arr = (j && j.services)||[];
      if(!arr.length){ svcInfo.textContent='Brak danych z /svc'; svcTable.style.display='none'; return; }
      svcInfo.textContent=''; svcTable.style.display='';
      svcTs.textContent = '· ' + new Date().toLocaleTimeString();
      svcBody.innerHTML = arr.map(s => {
        const unit = s.unit || '';
        const desc = s.desc || '';
        const act = badge(s.active, s.sub);
        const en = badgeEnabled(s.enabled);
        return `<tr>
          <td style="font-family:ui-monospace,Consolas,monospace">${unit}</td>
          <td>${desc}</td>
          <td>${act}</td>
          <td>${en}</td>
          <td class="svc-actions">
            <button data-unit="${unit}" data-a="start">start</button>
            <button data-unit="${unit}" data-a="stop">stop</button>
            <button data-unit="${unit}" data-a="restart">restart</button>
            <button data-unit="${unit}" data-a="enable">enable</button>
            <button data-unit="${unit}" data-a="disable">disable</button>
          </td>
        </tr>`;
      }).join('');
    }catch(e){
      svcInfo.textContent = 'Błąd /svc: ' + e;
      svcTable.style.display='none';
    }
  }
  setInterval(()=>{ try{fetchServices();}catch(_){ } }, 4000); fetchServices();

  // akcje /svc z pełną diagnostyką
  async function svcAction(unit, action){
    let status = 0, text = '', json = null;
    try{
      const r = await fetch('/svc/' + encodeURIComponent(unit), {
        method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({action})
      });
      status = r.status;
      text = await r.text();
      try { json = JSON.parse(text); } catch {}
      const ok = (r.ok && json && json.ok === true);
      const msg = (json && (json.stderr || json.stdout || json.error)) || (text && text.trim()) || `HTTP ${status}`;
      appendLog(`/svc ${action} ${unit} → ${status} :: ${msg}`, ok ? 'ok' : 'err');
    }catch(e){
      appendLog(`/svc ${action} ${unit} → network :: ${String(e)}`, 'err');
    }finally{
      try{ await fetchServices(); }catch(_){}
      try{ await probeLastFrameAge(); }catch(_){}
    }
  }
  qs('#svcBody').addEventListener('click', ev=>{
    try{
      const btn = ev.target.closest('button'); if(!btn) return;
      btn.disabled = true;
      const unit = btn.getAttribute('data-unit'); const action = btn.getAttribute('data-a');
      svcAction(unit, action).finally(()=>{ try{btn.disabled=false;}catch(_){} });
    }catch(_){}
  });

  // przełączniki źródła
  async function useEdge(){ try{ await svcAction('rider-cam-preview.service','stop'); await svcAction('rider-edge-preview.service','start'); }catch(_){} }
  async function useCam(){  try{ await svcAction('rider-edge-preview.service','stop'); await svcAction('rider-cam-preview.service','start'); }catch(_){} }
  qs('#btnUseEdge').addEventListener('click', ()=>{ try{useEdge();}catch(_){ } });
  qs('#btnUseCam').addEventListener('click',  ()=>{ try{useCam(); }catch(_){ } });

  // heurystyka źródła
  async function guessFrameSource(){
    try{
      const r = await fetch('/svc', {cache:'no-store'}); const j = await r.json();
      const list = (j && j.services)||[];
      const isActive = (name)=> !!list.find(s => s.unit===name && s.active==='active');
      if(isActive('rider-edge-preview.service')) return 'edge';
      if(isActive('rider-cam-preview.service'))  return 'cam';
      if(isActive('rider-vision.service'))       return 'vision';
      return 'none';
    }catch{ return 'n/a'; }
  }

  // SSE z auto-reconnect
  let es=null, esTimer=null, esDelay=1000;
  function esConnect(){
    try{
      if(es){ try{es.close();}catch(_){ } es=null; }
      es = new EventSource('/events');
      es.onopen = ()=>{ appendLog('SSE connected'); esDelay=1000; };
      es.onmessage=(ev)=>{ try{ const obj=JSON.parse(ev.data); appendLog(obj.topic? `${obj.topic}`: 'event'); }catch{ appendLog('event'); } };
      es.onerror = ()=>{
        appendLog('SSE disconnected — reconnecting…','warn');
        try{ es.close(); }catch(_){}
        clearTimeout(esTimer);
        esTimer = setTimeout(esConnect, Math.min(esDelay, 10000));
        esDelay = Math.min(esDelay*2, 10000);
      };
    }catch(e){
      appendLog('SSE init failed: '+e,'err');
      clearTimeout(esTimer);
      esTimer = setTimeout(esConnect, Math.min(esDelay, 10000));
      esDelay = Math.min(esDelay*2, 10000);
    }
  }
  esConnect();
</script>
</body>
</html>
