<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rider-Pi — Sterowanie ruchem (REST /api)</title>
  <style>
    :root { --pad: 16px; --gap: 12px; }
    body{ font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif; margin:0; padding:var(--pad); background:#0e1823; color:#e6eef7; }
    .wrap{max-width:1100px;margin:0 auto}
    h1{font-size:20px;margin:0 0 var(--pad)}
    .row{display:flex;flex-wrap:wrap;gap:var(--gap);align-items:center;margin:8px 0}
    .grid{display:grid;grid-template-columns:repeat(3,160px);gap:var(--gap);justify-content:center;margin:16px 0}
    .card{ background:#0f2030; border:1px solid #1e3a56; border-radius:16px; box-shadow:0 1px 8px rgba(0,0,0,.25); padding:var(--pad); margin:0 0 var(--pad); }
    button{ padding:12px 16px; border:1px solid #24425e; border-radius:12px; background:#122435; color:#e6eef7; font-size:16px; cursor:pointer; transition:transform .03s ease, background .12s ease, border-color .12s ease; }
    button:hover{ background:#16304a; border-color:#2b5577 } button:active{ transform:scale(0.98) }
    .btn-sm{ padding:6px 10px; font-size:13px; border-radius:10px }
    label{font-size:14px;color:#b7cee3;display:flex;align-items:center;gap:8px}
    input[type="range"]{width:160px; accent-color:#6de28a}
    input[type="number"]{ width:100px;background:#0b1a27;color:#e6eef7; border:1px solid #24425e;border-radius:10px;padding:6px 8px }
    #log{ height:220px; overflow:auto; background:#0b1a27; border:1px solid #1c3349; border-radius:10px; padding:8px; font-family:ui-monospace,Consolas,monospace; font-size:13px; white-space:pre-wrap; }
    .muted{opacity:.85} .ok{color:#6de28a} .warn{color:#f0c36d} .err{color:#ff8080}
    .kbd{ font-family:ui-monospace,Consolas,monospace; background:#102233; border:1px solid #203a57; border-radius:6px; padding:2px 6px; margin:0 2px; color:#b7cee3 }
    .spacer{flex:1} a{color:#98c7ff; text-decoration:none} a:hover{text-decoration:underline}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:2px 8px;border-radius:999px;font-size:12px;border:1px solid #24425e;background:#0b1a27}
    .pill.ok{color:#6de28a;border-color:#2c6b48} .pill.err{color:#ff8080;border-color:#8a3a3a} .pill.warn{color:#f0c36d;border-color:#8a6a2c}
    .svc-table{width:100%;border-collapse:collapse;margin-top:8px}
    .svc-table th,.svc-table td{border-top:1px solid #1c3349;padding:8px 6px;text-align:left;font-size:14px}
    .svc-table td:nth-child(3), .svc-table td:nth-child(4){ white-space:nowrap; }
    .svc-actions{ white-space:nowrap; }
    .svc-actions button{ display:inline-block; padding:6px 10px; font-size:14px; margin:2px 3px; border-radius:10px }
    .cam{width:100%;max-width:480px;border-radius:12px;border:1px solid #1c3349;background:#0b1a27; display:block; margin:0 auto;}
    .note{font-size:13px;color:#b7cee3}
  </style>
</head>
<body>
<div class="wrap">

  <h1 data-i18n="meta.app_title">
    Rider-Pi — Sterowanie ruchem (REST /api)
    <span id="apiStatus" class="muted" style="margin-left:8px" data-i18n="header.api_status_checking">(checking…)</span>
    <span id="obstBadge" class="pill warn" style="margin-left:10px;display:none" data-i18n="header.obstacle_na">Obstacle: n/a</span>
  </h1>

  <!-- 1) KAMERA (na górze) -->
  <div class="card" style="position:relative">
    <h2 style="font-size:16px;margin:0 0 8px" data-i18n="camera.title">Podgląd kamery</h2>

    <!-- przyciski po prawej -->
    <div style="position:absolute; right:16px; top:16px; display:flex; gap:8px; align-items:flex-end;">
      <button id="camToggle" class="btn-sm" data-i18n="camera.auto_refresh_on">⟳ Auto-refresh (on)</button>
      <button id="btnUseEdge" class="btn-sm" data-i18n="camera.use_edge">Use EDGE</button>
      <button id="btnUseCam"  class="btn-sm" data-i18n="camera.use_cam">Use CAM</button>
    </div>

    <!-- obrazek wycentrowany -->
    <div class="row" style="align-items:flex-start; justify-content:center">
      <div>
        <img id="camPrev" class="cam" alt="camera preview" src="/camera/last?ts=0" />
        <div class="note" id="camInfo" style="margin-top:6px" data-i18n="camera.last_frame_na">last frame: n/a · source: n/a</div>
      </div>
    </div>
  </div>

  <!-- 2) STEROWANIE -->
  <div class="card">
    <h2 style="font-size:16px;margin:0 0 8px" data-i18n="motion.title">Sterowanie ruchem</h2>

    <div class="row" style="margin:6px 0 10px">
      <label>
        <span data-i18n="motion.turning_speed">Prędkość skrętu</span>
        <span class="muted" data-i18n="motion.turning_range">(0..1)</span>:
        <input id="speedSpin" type="range" min="0" max="1" step="0.02" value="0.18" />
        <span id="speedSpinVal">0.18</span>
      </label>
      <label>
        <span data-i18n="motion.pulse_time">Czas impulsu [s]</span>:
        <input id="durationSpin" type="number" min="0.05" step="0.05" value="0.10" />
      </label>
      <div class="spacer"></div>
      <button id="btnStop" data-i18n="motion.btn_stop">■ STOP</button>
    </div>

    <div class="grid">
      <div></div>
      <button id="btnFwd" data-i18n="motion.btn_forward">↑ Forward</button>
      <div></div>
      <button id="btnLeft" data-i18n="motion.btn_left">← Left</button>
      <button id="btnStop2" data-i18n="motion.btn_stop_small">■ Stop</button>
      <button id="btnRight" data-i18n="motion.btn_right">Right →</button>
      <div></div>
      <button id="btnBack" data-i18n="motion.btn_backward">↓ Backward</button>
      <div></div>
    </div>

    <div class="row">
      <span class="muted">
        <span data-i18n="motion.shortcuts_hint">Skróty</span>:
        <span class="kbd">W/S/A/D</span>
        <span data-i18n="motion.shortcuts_tail">lub strzałki; Spacja = stop.</span>
      </span>
      <div class="spacer"></div>
      <a href="/" class="muted" data-i18n="meta.dashboard">↩ dashboard</a>
    </div>
  </div>

  <!-- 3) USŁUGI -->
  <div class="card">
    <h2 style="font-size:16px;margin:0 0 8px">
      <span data-i18n="services.title">Usługi (systemd)</span>
      <button id="svcRefresh" class="btn-sm" style="margin-left:8px" data-i18n="services.refresh">⟳ odśwież</button>
    </h2>
    <div id="svcInfo" class="muted">
      <span data-i18n="meta.loading">Ładowanie…</span> <span id="svcTs"></span>
    </div>
    <table class="svc-table" id="svcTable" style="display:none">
      <thead>
        <tr>
          <th data-i18n="services.unit">Unit</th>
          <th data-i18n="services.desc">Opis</th>
          <th data-i18n="services.status">Status</th>
          <th data-i18n="services.autostart">Autostart</th>
          <th data-i18n="services.actions">Akcje</th>
        </tr>
      </thead>
      <tbody id="svcBody"></tbody>
    </table>
  </div>

  <!-- 4) LOG -->
  <div class="card">
    <h2 style="font-size:16px;margin:0 0 8px" data-i18n="events.title">Zdarzenia (SSE /events)</h2>
    <div id="log"></div>
  </div>
</div>

<!-- APP (i18n + logika) -->
<script type="module">
  import { initI18n, applyDom, t } from '/web/i18n.js';

  // --- Inicjalizacja języka z ?lang=, potem localStorage, potem język przeglądarki
  const urlLang = new URLSearchParams(location.search).get('lang');
  const saved = localStorage.getItem('lang');
  const browser = (navigator.language || '').slice(0,2).toLowerCase();
  const pick = (v)=> v && v.toLowerCase().startsWith('en') ? 'en' : (v && v.toLowerCase().startsWith('pl') ? 'pl' : null);
  const lang = pick(urlLang) || pick(saved) || pick(browser) || 'pl';
  if (urlLang) localStorage.setItem('lang', lang);
  await initI18n(lang);
  applyDom();                                 // <- KLUCZ: przetłumacz całą stronę
  document.documentElement.setAttribute('lang', lang);
  document.title = t('meta.app_title');

  // ====== poniżej oryginalna logika strony, z t() ======
  const qs = (s)=>document.querySelector(s);
  const logEl = qs('#log');
  function appendLog(msg, cls=""){ const line=document.createElement('div'); if(cls) line.className=cls; line.textContent=`[${new Date().toLocaleTimeString()}] ${msg}`; logEl.appendChild(line); logEl.scrollTop=logEl.scrollHeight; }
  window.addEventListener('error', e=> appendLog(`${t('events.log_js_err',{msg:e.message||e})}`, 'err'));
  window.addEventListener('unhandledrejection', e=> appendLog(`${t('events.log_prom_err',{reason:e.reason||e})}`, 'err'));

  const LIN_V = 0.10, LIN_T = 0.10;
  const spinEl = qs('#speedSpin'), spinVal = qs('#speedSpinVal'), durSpinEl = qs('#durationSpin');
  spinEl.addEventListener('input', ()=> spinVal.textContent = Number(spinEl.value).toFixed(2));
  function clamp(n, lo, hi){ n=Number(n)||0; return Math.max(lo, Math.min(hi, n)); }

  async function pingHealth(){
    try{
      const r=await fetch('/healthz',{cache:'no-store'}); const j=await r.json().catch(()=>({}));
      const apiStatus = qs('#apiStatus'); const ok=!!j.ok;
      apiStatus.textContent = ok ? t('header.api_status_ok') : t('header.api_status_degraded');
      apiStatus.className = ok?'ok':'warn';
    }catch{
      const apiStatus = qs('#apiStatus');
      apiStatus.textContent = t('header.api_status_down');
      apiStatus.className='err';
    }
  }
  setInterval(pingHealth, 1000); pingHealth();

  async function httpPost(url, body){
    const r=await fetch(url,{ method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(body)});
    const raw=await r.text(); let j=null; try{ j=JSON.parse(raw);}catch{}
    if(!r.ok){ throw new Error((j && (j.error||j.stderr||j.stdout)) || `HTTP ${r.status}`); }
    return j||{};
  }
  async function apiControl(obj){ try{ const j= await httpPost('/api/control', obj); appendLog(`api/control → ${JSON.stringify(obj)} :: ${JSON.stringify(j)}`, 'ok'); return j; }catch(e){ appendLog(`api/control ${JSON.stringify(obj)} :: ${e.message}`,'err'); } }
  async function doStop(){ try{ await apiControl({cmd:'stop'}); }catch{} }
  async function goF(){ const tsec=Math.max(0.05, LIN_T); await apiControl({cmd:'move', dir:'forward', v: LIN_V, t:tsec}); setTimeout(()=>{try{doStop();}catch{} } , Math.max(100, tsec*1000)); }
  async function goB(){ const tsec=Math.max(0.05, LIN_T); await apiControl({cmd:'move', dir:'backward', v: LIN_V, t:tsec}); setTimeout(()=>{try{doStop();}catch{} } , Math.max(100, tsec*1000)); }
  async function spin(dir){ const w=clamp(spinEl.value,0,1); const tsec=clamp(durSpinEl.value,0.05,5); await apiControl({cmd:'move', dir:(dir==='left'?'left':'right'), w, t:tsec}); setTimeout(()=>{try{doStop();}catch{} } , Math.max(100, tsec*1000)); }
  qs('#btnFwd').addEventListener('click', ()=>{try{goF();}catch{}});
  qs('#btnBack').addEventListener('click', ()=>{try{goB();}catch{}});
  qs('#btnLeft').addEventListener('click', ()=>{try{spin('left');}catch{}});
  qs('#btnRight').addEventListener('click', ()=>{try{spin('right');}catch{}});
  qs('#btnStop').addEventListener('click', ()=>{try{doStop();}catch{}});
  qs('#btnStop2').addEventListener('click', ()=>{try{doStop();}catch{}});

  const pressed = new Set(); const isArrow = k => ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(k);
  window.addEventListener('keydown', ev=>{ try{
    if(ev.repeat) return; const k=ev.key; if(isArrow(k)) ev.preventDefault(); pressed.add(k);
    if(k===' ') {ev.preventDefault(); doStop(); return;}
    if(k==='w'||k==='W'||k==='ArrowUp') goF();
    if(k==='s'||k==='S'||k==='ArrowDown') goB();
    if(k==='a'||k==='A'||k==='ArrowLeft') spin('left');
    if(k==='d'||k==='D'||k==='ArrowRight') spin('right');
  }catch{} });
  window.addEventListener('keyup', ev=>{ try{
    if(!pressed.has(ev.key)) return; pressed.delete(ev.key);
    if(['w','W','ArrowUp','s','S','ArrowDown','a','A','ArrowLeft','d','D','ArrowRight'].includes(ev.key)) doStop();
  }catch{} });
  document.addEventListener('visibilitychange', ()=> { if (document.hidden) { try{doStop();}catch{} } });
  window.addEventListener('beforeunload', ()=> { try { navigator.sendBeacon('/api/control', new Blob(['{"cmd":"stop"}'], {type:'application/json'})); } catch{} });

  // obstacle badge
  async function pollObstacle(){
    try{
      const r = await fetch('/vision/obstacle', {cache:'no-store'});
      if(!r.ok) throw 0;
      const j = await r.json().catch(()=>({}));
      const present = !!(j && (j.present || j.obstacle || (j.data && j.data.present)));
      const obstBadge = qs('#obstBadge');
      obstBadge.style.display = 'inline-flex';
      obstBadge.textContent = present ? t('header.obstacle_present') : t('header.obstacle_none');
      obstBadge.className = 'pill ' + (present ? 'err' : 'ok');
    }catch{
      const obstBadge = qs('#obstBadge');
      obstBadge.style.display = 'inline-flex';
      obstBadge.textContent = t('header.obstacle_na');
      obstBadge.className = 'pill warn';
    }
  }
  setInterval(pollObstacle, 1500); pollObstacle();

  // kamera
  const camImg = qs('#camPrev'); const camToggle = qs('#camToggle'); const camInfo = qs('#camInfo');
  let camAuto = true; let camTimer = null;
  function refreshCam(){ try{ camImg.src = '/camera/last?ts=' + Date.now(); }catch{} }
  function setCamAuto(on){
    camAuto = on; camToggle.textContent = on ? t('camera.auto_refresh_on') : t('camera.auto_refresh_off');
    if(camTimer){ clearInterval(camTimer); camTimer=null; }
    if(on){ refreshCam(); camTimer = setInterval(()=>{try{refreshCam();}catch{}}, 1500); }
  }
  camToggle.addEventListener('click', ()=> setCamAuto(!camAuto));
  setCamAuto(true);

  async function probeLastFrameAge(){
    try{
      const r = await fetch('/camera/last', { method:'HEAD', cache:'no-store' });
      const lm = r.headers.get('Last-Modified');
      let ageTxt = 'n/a';
      if(lm){
        const ts = new Date(lm).getTime();
        const age = Math.max(0, (Date.now()-ts)/1000);
        ageTxt = age.toFixed(1) + ' s';
      }
      const src = await guessFrameSource();
      camInfo.textContent = t('camera.last_frame', { age: ageTxt, src });
      camInfo.className = 'note ' + ((lm)? (parseFloat(ageTxt) < 3 ? 'ok':'warn') : 'err');
    }catch{
      camInfo.textContent = t('camera.last_frame_na');
      camInfo.className = 'note err';
    }
  }
  setInterval(probeLastFrameAge, 1500); probeLastFrameAge();

  // /svc
  const svcInfo = qs('#svcInfo'); const svcTable = qs('#svcTable'); const svcBody = qs('#svcBody'); const svcTs = qs('#svcTs');
  qs('#svcRefresh').addEventListener('click', ()=>{ try{fetchServices();}catch{} });

  function badge(active, sub){
    let cls='warn', txt=String(active||'unknown'); if(active==='active') cls='ok';
    if(active==='failed' || active==='inactive') cls=(active==='failed'?'err':'warn');
    return `<span class="pill ${cls}">${txt}${sub?` / ${sub}`:''}</span>`;
  }
  function badgeEnabled(state){
    let cls='warn'; if(state==='enabled') cls='ok'; if(state==='disabled') cls='warn';
    return `<span class="pill ${cls}">${state||'unknown'}</span>`;
  }

  async function fetchServices(){
    try{
      const r = await fetch('/svc', {cache:'no-store'});
      const j = await r.json().catch(()=>null);
      const arr = (j && j.services)||[];
      if(!arr.length){ svcInfo.innerHTML=t('services.empty'); svcTable.style.display='none'; return; }
      svcInfo.textContent=''; svcTable.style.display='';
      svcTs.textContent = '· ' + new Date().toLocaleTimeString();
      svcBody.innerHTML = arr.map(s => {
        const unit = s.unit || '';
        const desc = s.desc || '';
        const act = badge(s.active, s.sub);
        const en = badgeEnabled(s.enabled);
        return `<tr>
          <td style="font-family:ui-monospace,Consolas,monospace">${unit}</td>
          <td>${desc}</td>
          <td>${act}</td>
          <td>${en}</td>
          <td class="svc-actions">
            <button data-unit="${unit}" data-a="start">${t('services.btn_start')}</button>
            <button data-unit="${unit}" data-a="stop">${t('services.btn_stop')}</button>
            <button data-unit="${unit}" data-a="restart">${t('services.btn_restart')}</button>
            <button data-unit="${unit}" data-a="enable">${t('services.btn_enable')}</button>
            <button data-unit="${unit}" data-a="disable">${t('services.btn_disable')}</button>
          </td>
        </tr>`;
      }).join('');
    }catch(e){
      svcInfo.innerHTML = t('services.error_fetch', { msg: String(e) });
      svcTable.style.display='none';
    }
  }
  setInterval(fetchServices, 4000); fetchServices();

  async function svcAction(unit, action){
    let status = 0, text = '', json = null;
    try{
      const r = await fetch('/svc/' + encodeURIComponent(unit), {
        method:'POST', headers:{'Content-Type':'application/json'},
        body: JSON.stringify({action})
      });
      status = r.status;
      text = await r.text();
      try { json = JSON.parse(text); } catch {}
      const ok = (r.ok && json && json.ok === true);
      const msg = (json && (json.stderr || json.stdout || json.error)) || (text && text.trim()) || `HTTP ${status}`;
      appendLog(t('services.log_action', { action, unit, code: status, msg }), ok ? 'ok' : 'err');
    }catch(e){
      appendLog(t('services.log_action', { action, unit, code: 'net', msg: String(e) }), 'err');
    }finally{
      try{ await fetchServices(); }catch{}
      try{ await probeLastFrameAge(); }catch{}
    }
  }
  qs('#svcBody').addEventListener('click', ev=>{
    try{
      const btn = ev.target.closest('button'); if(!btn) return;
      btn.disabled = true;
      const unit = btn.getAttribute('data-unit'); const action = btn.getAttribute('data-a');
      svcAction(unit, action).finally(()=>{ try{btn.disabled=false;}catch{} });
    }catch{}
  });

  async function useEdge(){ try{ await svcAction('rider-cam-preview.service','stop'); await svcAction('rider-edge-preview.service','start'); }catch{} }
  async function useCam(){  try{ await svcAction('rider-edge-preview.service','stop'); await svcAction('rider-cam-preview.service','start'); }catch{} }
  qs('#btnUseEdge').addEventListener('click', ()=>{ try{useEdge();}catch{} });
  qs('#btnUseCam').addEventListener('click',  ()=>{ try{useCam(); }catch{} });

  async function guessFrameSource(){
    try{
      const r = await fetch('/svc', {cache:'no-store'}); const j = await r.json();
      const list = (j && j.services)||[];
      const isActive = (name)=> !!list.find(s => s.unit===name && s.active==='active');
      if(isActive('rider-edge-preview.service')) return t('camera.src_edge');
      if(isActive('rider-cam-preview.service'))  return t('camera.src_cam');
      if(isActive('rider-vision.service'))       return t('camera.src_vision');
      return t('camera.src_none');
    }catch{ return 'n/a'; }
  }

  // SSE
  let es=null, esTimer=null, esDelay=1000;
  function esConnect(){
    try{
      if(es){ try{es.close();}catch{} es=null; }
      es = new EventSource('/events');
      es.onopen = ()=>{ appendLog(t('events.sse_connected')); esDelay=1000; };
      es.onmessage=(ev)=>{ try{ const obj=JSON.parse(ev.data); appendLog(obj.topic? `${obj.topic}`: t('events.generic_event')); }catch{ appendLog(t('events.generic_event')); } };
      es.onerror = ()=>{
        appendLog(t('events.sse_reconnect'),'warn');
        try{ es.close(); }catch{}
        clearTimeout(esTimer);
        esTimer = setTimeout(esConnect, Math.min(esDelay, 10000));
        esDelay = Math.min(esDelay*2, 10000);
      };
    }catch(e){
      appendLog(t('events.sse_init_err',{err:String(e)}),'err');
      clearTimeout(esTimer);
      esTimer = setTimeout(esConnect, Math.min(esDelay, 10000));
      esDelay = Math.min(esDelay*2, 10000);
    }
  }
  esConnect();
</script>
</body>
</html>

