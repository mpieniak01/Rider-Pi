<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rider-Pi — Sterowanie ruchem (REST /api)</title>
  <style>
    /* DARK THEME — spójne z głównym dashboardem */
    :root { --pad: 16px; --gap: 12px; }
    body{
      font-family:system-ui,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
      margin:0; padding:var(--pad);
      background:#0e1823; color:#e6eef7;
    }
    .wrap{max-width:1100px;margin:0 auto}
    h1{font-size:20px;margin:0 0 var(--pad)}
    .row{display:flex;flex-wrap:wrap;gap:var(--gap);align-items:center;margin:8px 0}
    .grid{display:grid;grid-template-columns:repeat(3,160px);gap:var(--gap);justify-content:center;margin:16px 0}

    .card{
      background:#0f2030;
      border:1px solid #1e3a56;
      border-radius:16px;
      box-shadow:0 1px 8px rgba(0,0,0,.25);
      padding:var(--pad); margin:0 0 var(--pad);
    }

    button{
      padding:12px 16px;
      border:1px solid #24425e;
      border-radius:12px;
      background:#122435; color:#e6eef7;
      font-size:16px; cursor:pointer;
      transition:transform .03s ease, background .12s ease, border-color .12s ease;
    }
    button:hover{ background:#16304a; border-color:#2b5577 }
    button:active{ transform:scale(0.98) }

    label{font-size:14px;color:#b7cee3;display:flex;align-items:center;gap:8px}
    input[type="range"]{width:160px; accent-color:#6de28a}
    input[type="number"]{
      width:100px;background:#0b1a27;color:#e6eef7;
      border:1px solid #24425e;border-radius:10px;padding:6px 8px
    }
    select{
      padding:8px 10px;border-radius:10px;
      border:1px solid #24425e;background:#0b1a27;color:#e6eef7
    }

    #log{
      height:220px; overflow:auto;
      background:#0b1a27; border:1px solid #1c3349;
      border-radius:10px; padding:8px;
      font-family:ui-monospace,Consolas,monospace; font-size:13px;
      white-space:pre-wrap;
    }

    .muted{opacity:.85}
    .ok{color:#6de28a}
    .warn{color:#f0c36d}
    .err{color:#ff8080}
    .kbd{
      font-family:ui-monospace,Consolas,monospace;
      background:#102233; border:1px solid #203a57;
      border-radius:6px; padding:2px 6px; margin:0 2px; color:#b7cee3
    }
    .spacer{flex:1}
    a{color:#98c7ff; text-decoration:none}
    a:hover{text-decoration:underline}
  </style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>Rider-Pi — Sterowanie ruchem
      <span id="apiStatus" class="muted" style="margin-left:8px">(checking…)</span>
    </h1>
    <div class="row">
      <label>Tryb lewo/prawo:
        <select id="lrMode">
          <option value="turn" selected>skręt (yaw)</option>
          <option value="strafe">straf (vy)</option>
        </select>
      </label>
      <label>Prędkość skrętu <span class="muted">(0..1)</span>:
        <input id="speedSpin" type="range" min="0" max="1" step="0.05" value="0.30" />
        <span id="speedSpinVal">0.30</span>
      </label>
      <label>Czas skrętu [s]:
        <input id="durationSpin" type="number" min="0.1" step="0.05" value="0.45" />
      </label>
      <div class="spacer"></div>
      <button id="btnStop">■ STOP</button>
    </div>

    <div class="grid">
      <div></div>
      <button id="btnFwd">↑ Forward</button>
      <div></div>

      <button id="btnLeft">← Left</button>
      <button id="btnStop2">■ Stop</button>
      <button id="btnRight">Right →</button>

      <div></div>
      <button id="btnBack">↓ Backward</button>
      <div></div>
    </div>

    <div class="row">
      <span class="muted">Skróty: <span class="kbd">W</span>/<span class="kbd">S</span>/<span class="kbd">A</span>/<span class="kbd">D</span> lub strzałki; <span class="kbd">Spacja</span> = stop.</span>
      <div class="spacer"></div>
      <a href="/" class="muted">↩ dashboard</a>
    </div>
  </div>

  <div class="card">
    <h2 style="font-size:16px;margin:0 0 8px">Zdarzenia (SSE /events)</h2>
    <div id="log"></div>
  </div>
</div>

<script>
  // ====== USTAWIENIA DOMYŚLNE (spójne z manualem) ======
  // mały "nudge" F/B – żeby nie spadać z biurka:
  const LIN_V = 0.05;
  const LIN_T = 0.15;

  const qs = (s)=>document.querySelector(s);
  const spinEl = qs('#speedSpin');
  const spinVal = qs('#speedSpinVal');
  const durSpinEl = qs('#durationSpin');
  const lrModeEl = qs('#lrMode');
  const logEl = qs('#log');
  const apiStatus = qs('#apiStatus');

  function clamp(n, lo, hi){ n=Number(n)||0; return Math.max(lo, Math.min(hi, n)); }
  spinEl.addEventListener('input', ()=> spinVal.textContent = Number(spinEl.value).toFixed(2));

  // ====== HEALTH ======
  async function pingHealth(){
    try{
      const r = await fetch('/healthz', {cache:'no-store'});
      if(!r.ok) throw new Error(r.status);
      const j = await r.json().catch(()=>({status:r.ok?'ok':'degraded'}));
      const ok = (j.status === 'ok') || r.ok;
      apiStatus.textContent = ok ? 'ok' : 'degraded';
      apiStatus.className = ok ? 'ok' : 'warn';
    }catch(e){
      apiStatus.textContent = 'down';
      apiStatus.className = 'err';
    }
  }
  setInterval(pingHealth, 1000); pingHealth();

  // ====== LOG ======
  function appendLog(msg, cls="") {
    const line = document.createElement('div');
    if (cls) line.className = cls;
    line.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`;
    logEl.appendChild(line);
    logEl.scrollTop = logEl.scrollHeight;
  }

  // ====== WYSYŁKA KOMEND (z fallbackami) ======
  async function httpPost(url, body, headers) {
    const r = await fetch(url, {
      method: 'POST',
      headers: Object.assign({'Content-Type':'application/json'}, headers||{}),
      body: JSON.stringify(body),
    });
    if (!r.ok) throw new Error(`${r.status} ${r.statusText}`);
    return r;
  }

  // 1) preferujemy /api/cmd {type:...} → 2) /cmd → 3) /pub {topic,message}
  async function sendCmd(obj) {
    const tries = [
      {url:'/api/cmd', type:'json'},
      {url:'/cmd',     type:'json'},
      {url:'/pub',     type:'pub'},
    ];
    let lastErr = null;
    for (const t of tries) {
      try {
        if (t.type === 'json') {
          await httpPost(t.url, obj);
        } else {
          await httpPost(t.url, {topic:'motion.cmd', message: JSON.stringify(obj)});
        }
        appendLog(`cmd → ${JSON.stringify(obj)}`, 'ok');
        return true;
      } catch(e){ lastErr = e; }
    }
    appendLog(`ERROR cmd: ${lastErr ? lastErr.message : 'unknown'}`, 'err');
    return false;
  }

  // Stary endpoint kompatybilności: /api/move {vx,vy,yaw,duration}
  async function sendMoveLegacy(vx, vy, yaw, duration) {
    try {
      await httpPost('/api/move', {vx, vy, yaw, duration});
      appendLog(`move → ${JSON.stringify({vx,vy,yaw,duration})}`, 'ok');
      return true;
    } catch(e) {
      appendLog(`ERROR move: ${e.message}`, 'err');
      return false;
    }
  }

  // ====== AKCJE ======
  async function doStop() {
    // 1) /api/stop → 2) /api/cmd stop → 3) /pub
    try {
      await httpPost('/api/stop', {});
      appendLog('stop', 'warn');
      return;
    } catch(_) {}
    const ok = await sendCmd({type:'stop'});
    if (!ok) {
      try { await httpPost('/pub', {topic:'motion.cmd', message:'{"type":"stop"}'}); appendLog('stop(pub)', 'warn'); } catch(e){ appendLog(`ERROR stop: ${e.message}`, 'err'); }
    }
  }

  async function goF() {
    // mały impuls f/b (LIN_V, LIN_T) – zgodnie z manualem
    const ok = await sendCmd({type:'drive', lx: LIN_V, az: 0.0});
    if (!ok) await sendMoveLegacy(+LIN_V, 0, 0, LIN_T);
    setTimeout(doStop, Math.max(50, LIN_T*1000));
  }

  async function goB() {
    const ok = await sendCmd({type:'drive', lx: -LIN_V, az: 0.0});
    if (!ok) await sendMoveLegacy(-LIN_V, 0, 0, LIN_T);
    setTimeout(doStop, Math.max(50, LIN_T*1000));
  }

  async function spin(dir){ // dir: 'left' | 'right'
    const s = clamp(spinEl.value, 0, 1), t = clamp(durSpinEl.value, 0.1, 5);
    // 1) spróbuj komendę spin (która u nas wywołuje vendor turnleft/turnright)
    const ok = await sendCmd({type:'spin', dir, speed:s, dur:t});
    if (ok) { setTimeout(doStop, Math.max(100, t*1000)); return; }

    // 2) fallback do starego /api/move (yaw)
    if (lrModeEl.value === 'turn') {
      const yaw = (dir === 'left' ? -s : +s); // kierunek zgodny z poprzednią stroną (Δyaw ujemny = lewo)
      await sendMoveLegacy(0, 0, yaw, t);
    } else {
      // alternatywa: strafe vy
      const vy = (dir === 'left' ? -s : +s);
      await sendMoveLegacy(0, vy, 0, t);
    }
    setTimeout(doStop, Math.max(100, t*1000));
  }

  // ====== BUTTONS ======
  qs('#btnFwd').addEventListener('click', goF);
  qs('#btnBack').addEventListener('click', goB);
  qs('#btnLeft').addEventListener('click', ()=> spin('left'));
  qs('#btnRight').addEventListener('click', ()=> spin('right'));
  qs('#btnStop').addEventListener('click', doStop);
  qs('#btnStop2').addEventListener('click', doStop);

  // ====== KEYBOARD ======
  const pressed = new Set();
  function isArrow(k){ return ['ArrowUp','ArrowDown','ArrowLeft','ArrowRight'].includes(k); }
  window.addEventListener('keydown', (ev)=>{
    if (ev.repeat) return;
    const k = ev.key;
    if (isArrow(k)) ev.preventDefault();
    pressed.add(k);
    if (k === ' '){ ev.preventDefault(); doStop(); return; }
    if (k === 'w' || k === 'W' || k === 'ArrowUp')   goF();
    if (k === 's' || k === 'S' || k === 'ArrowDown') goB();
    if (k === 'a' || k === 'A' || k === 'ArrowLeft') spin('left');
    if (k === 'd' || k === 'D' || k === 'ArrowRight')spin('right');
  });
  window.addEventListener('keyup', (ev)=>{
    if (!pressed.has(ev.key)) return;
    pressed.delete(ev.key);
    if (['w','W','ArrowUp','s','S','ArrowDown','a','A','ArrowLeft','d','D','ArrowRight'].includes(ev.key)) {
      doStop();
    }
  });

  // Awaryjny STOP przy ukryciu/wyjściu ze strony
  document.addEventListener('visibilitychange', ()=> { if (document.hidden) doStop(); });
  window.addEventListener('beforeunload', ()=> {
    try { navigator.sendBeacon('/api/stop', new Blob(['{}'], {type:'application/json'})); } catch(e){}
  });

  // ====== SSE /events ======
  try{
    const es = new EventSource('/events');
    es.onmessage = (ev)=> {
      try{
        const obj = JSON.parse(ev.data);
        let line = obj.topic || 'event';
        if (typeof obj.data === 'string') {
          try {
            const d = JSON.parse(obj.data);
            if (d.event) line += ` :: ${d.event}`;
            else if (d.vx!==undefined || d.yaw!==undefined) line += ` :: ${JSON.stringify(d)}`;
          } catch(_){}
        }
        appendLog(line);
      }catch(e){
        appendLog(`event ${ev.data}`);
      }
    };
    es.onerror = ()=> appendLog('SSE disconnected', 'warn');
    appendLog('SSE connected');
  }catch(e){
    appendLog('SSE not supported', 'warn');
  }
</script>
</body>
</html>
